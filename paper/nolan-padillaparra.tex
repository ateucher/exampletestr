% !TeX root = RJwrapper.tex
%\title{\pkg{exampletestr}: Making it Easier to Start Writing Unit Tests with \pkg{testthat}.}
\title{Easier Unit Tests and Better Examples with \pkg{exampletestr}}
\author{by Rory Nolan and Sergi Padilla-Parra}

\maketitle

\abstract{
In spite of the utility of unit tests, most R package developers do not write them. \CRANpkg{exampletestr} makes it easier to \emph{start} writing unit tests by creating shells/skeletons of unit tests based on the examples in the user's package documentation. When completed, these unit tests test whether said examples run \emph{correctly}. By combining \pkg{exampletestr} with the \CRANpkg{covr} package, one has access to a convenient workflow to ensure (i) that the unit tests test as many parts of the code as feasible and (ii) that the examples in the documentation demonstrate as many features of the package as possible. 
}

\section{A survey of unit testing}
Let us take a look at how many packages on CRAN employ unit tests with the recognised testing frameworks \CRANpkg{testthat} \citep{testthat}, \CRANpkg{RUnit} \citep{RUnit}, \CRANpkg{svUnit} \citep{svUnit} and \CRANpkg{unitizer} \citep{unitizer}. We examine first all packages and then the subset that were authored or updated in 2016 or 2017 [code adapted from \citet{mango}].

\begin{example}
library(tidyverse)
download.file("http://cran.R-project.org/web/packages/packages.rds",
              "packages.rds", mode = "wb")
cran_packages <- readRDS("packages.rds")
nrow(cran_packages)
#> [1] 10465

unit_test_packages <- c("testthat", "RUnit", "svUnit", "unitizer")
reverse_deps <- tools:::package_dependencies(packages = unit_test_packages,
                  cran_packages, recursive=FALSE, reverse=TRUE,
                  which = c("Depends","Imports","LinkingTo", "Suggests"))
map_int(reverse_deps, length)
#> testthat    RUnit   svUnit unitizer 
#>     1928      134       11        0


library(lubridate)
post2015 <- ymd(cran_packages[, "Published"]) >= ymd("2016-01-01")
sum(post2015, na.rm = TRUE)
#> [1] 5999
new_packages <- cran_packages[post2015, ]
reverse_deps <- tools:::package_dependencies(packages = unit_test_packages,
                  new_packages, recursive=FALSE, reverse=TRUE,
                  which = c("Depends","Imports","LinkingTo", "Suggests"))
map_int(reverse_deps, length)
#> testthat    RUnit   svUnit unitizer 
#>     1646       58        5        0
\end{example}
So we see that (at the time of writing) of the 10465 packages on CRAN, 20\% (2073) are unit tested. Of the 5999 authored or updated since $1^\text{st}$ January 2016, 28\% (1709) are unit tested. We also see that \pkg{testthat} is the most popular testing framework, preferred in 93\% of cases.
Although these statistics suggest that developers' propensity to write tests is improving, it is still low. Perhaps this is because the task of unit testing an entire package from scratch can seem daunting. 
\pkg{exampletestr} makes it easier, providing a template of tests to be filled in. Those beginning to unit test no longer need to start with a blank page.% to start by providing a template of unit tests based
%I am of the opinion that if one can just \emph{start} writing the tests, seeing the bugs that they discover and fix, and seeing their test coverage go up (via the \pkg{covr} package, \citet{covr}), one will quickly embrace the advantages of writing tests and realise that doing so is not overly taxing.

\section{Unit test shells based on documentation examples}
Most packages \emph{do} contain examples in their documentation (indeed Bioconductor \citep{bioc} requires documented functions to have at least one example). \samp{R CMD check} checks that these examples run without error, but cannot verify that they run \emph{as intended}. Most package developers will run their examples interactively at the command prompt to verify that they run correctly; this clearly suggests a corresponding unit test which automatically performs the same check. The \pkg{exampletestr} package \citep{exampletestr} does much of the work of writing \emph{these} tests. It uses the \pkg{testthat} testing framework.

The best way to display the functionality of \pkg{exampletestr} is by example. Take the \samp{str\_detect} function from the \CRANpkg{stringr} package \citep{stringr}. The man file \file{str\_detect.Rd} has the examples section:
\begin{verbatim}
\examples{
fruit <- c("apple", "banana", "pear", "pinapple")
str_detect(fruit, "a")
str_detect(fruit, "^a")
str_detect(fruit, "a$")
str_detect(fruit, "b")
str_detect(fruit, "[aeiou]")
# Also vectorised over pattern
str_detect("aecfg", letters)
}
\end{verbatim}
The \dfn{test shell} that would be automatically created by \pkg{exampletestr} from these examples is:
\begin{verbatim}
test_that("str_detect works", {
  fruit <- c("apple", "banana", "pear", "pinapple")
  expect_equal(str_detect(fruit, "a"), )
  expect_equal(str_detect(fruit, "^a"), )
  expect_equal(str_detect(fruit, "a$"), )
  expect_equal(str_detect(fruit, "b"), )
  expect_equal(str_detect(fruit, "[aeiou]"), )
  expect_equal(str_detect("aecfg", letters), )
})
\end{verbatim}
which is then filled in by the package developer to give the complete and passing test:
\begin{verbatim}
test_that("str_detect works", {
  fruit <- c("apple", "banana", "pear", "pinapple")
  expect_equal(str_detect(fruit, "a"), rep(TRUE, 4))
  expect_equal(str_detect(fruit, "^a"), c(TRUE, rep(FALSE, 3)))
  expect_equal(str_detect(fruit, "a$"), c(FALSE, TRUE, FALSE, FALSE))
  expect_equal(str_detect(fruit, "b"), c(FALSE, TRUE, FALSE, FALSE))
  expect_equal(str_detect(fruit, "[aeiou]"), rep(TRUE, 4))
  expect_equal(str_detect("aecfg", letters), 
               c(TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, TRUE, rep(FALSE, 19)))
})
\end{verbatim}
By running \samp{make\_tests\_shells\_pkg()} in the root directory of one's package, for each \file{x.R} file in the \file{R/} directory which has at least one function documented with an example, one gets a corresponding file \file{test\_x.R} in the \file{tests/testthat/} directory of the package, containing these corresponding test shells to be filled in to create fully functional unit tests.
For a more comprehensive overview of \pkg{exampletestr}'s capabilities, consult the package's manual and vignette. 

The important point is that \pkg{exampletestr} takes care of much of the formulation of many unit tests for developers who have already created a package with adequate examples. This should encourage those who have never written unit tests to make a start and should also make unit testing easier for those who already do it.

\section{A workflow for writing comprehensive examples and unit tests}
The idea of basing unit tests around documentation examples suggests the following workflow to ensure both that unit tests cover as much of the source code as feasible (the original idea of \pkg{covr}) and that the examples in the documentation exhibit as much of the functionality of the package as possible:
\begin{enumerate}
	\item Write unit tests corresponding to \emph{all} of your examples using \pkg{exampletestr}.
%	\begin{itemize}
%		\item Write other unit tests (without the help of \pkg{exampletestr}) as you see fit.
%	\end{itemize}
	\item View your test coverage with the \pkg{covr} package via \samp{shine(package\_coverage())}.
	\item For each part of your code which is of interest to the end-user is not covered, write \emph{both} a new example exemplifying this functionality \emph{and} a corresponding unit test.
	\item For each part of your code which is not covered but is not of great interest to the end user (e.g. an error that should be thrown in an obscure special case), if you are not sure it will run correctly, write a unit test to cover it; there is no need to write a corresponding example.
\end{enumerate}
Using this workflow, the developer ensures not only that their test coverage is good, but also that their \dfn{example coverage} (the portion of package features covered by documentation examples) is adequate, such that these examples demonstrate all useful code features. 

%The idea of example coverage suggests the development a package which directly analyses the code coverage of examples. This would enable a simpler workflow for comprehensive example writing analogous to the one enabled by \pkg{covr} for comprehensive unit testing. 

\section{Good practice}
One should not necessarily leave unit testing until last in the package creation workflow. However, that is already the case for the packages on CRAN which are not unit tested (a majority). \citet{r-pkgs} has some nice advice for writing tests. \pkg{exampletestr} promotes a "one test per function" model. This will not always be ideal so take care to reorganise tests into a better structure when necessary. 

If writing tests before employing the above workflow, one should always consider whether the behaviour being tested warrants an accompanying example. If it does, write both at the \emph{same time}. Failure to do so could result in example coverage being overestimated.

%\pkg{exampletestr} helps one to test whether their examples run correctly. This may not be the only type of test that is required to adequately test a package and hence, many unit tests may still need to be written from scratch.

This package will not write a single \emph{complete} expectation (\samp{expect\_equal()}, \samp{expect\_true()}, etc.) expression, nor should there be a routine that does so. Unit tests are meant to be automatic in the sense that they can be run automatically, however their creation is intended to involve a manual check. With \pkg{exampletestr}, this manual check is one's manual completion of the expectation expression.

\bibliography{nolan}

\address{Rory Nolan\\
  Wellcome Trust Centre for Human Genetics, University of Oxford\\
  OX3 7BN\\
  United Kingdom\\}
\email{rnolan@well.ox.ac.uk}

\address{Sergi Padilla-Parra\\
  Wellcome Trust Centre for Human Genetics and Division of Structural Biology, University of Oxford\\
  OX3 7BN\\
  United Kingdom\\}
\email{spadilla@well.ox.ac.uk}
